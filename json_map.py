# json-map, a tiled JSON map renderer for pyglet
# Copyright (C) 2014 Juan J. Martinez <jjm@usebox.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

"""
A Tiled JSON map renderer for pyglet.

These classes use the JSON format as generated by Tiled JSON plugin.

`pyglet.resource` framework is used to load all the elements of the map, so
any path information must be removed from the tileset.

"""
import math
import os
import json

os.sys.path.insert(0, '.')
ZOOM = 2
import pyglet
from pyglet.gl import glMatrixMode, gluOrtho2D, glScalef, glTexParameteri, GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, \
    GL_TEXTURE_MIN_FILTER, GL_NEAREST, glFlush
from pyglet.gl import GL_PROJECTION
from pyglet.gl import glLoadIdentity
from pyglet.graphics import OrderedGroup
from pyglet.sprite import Sprite

from pyglet import gl
from player import PlayerAnimatedObject, GooseObject
from gamestate import GameState
__all__ = ['Map', "TileLayer", "ObjectGroup", ]
warp_slow_x = 0.5
warp_slow_y = 0.5
warp_very_slow_x = 0.3
warp_very_slow_y = 0.3


def get_texture_sequence(filename, tilewidth=32, tileheight=32, margin=1, spacing=1, nearest=False):
    """Returns a texture sequence of a grid generated from a tile set."""

    image = pyglet.resource.image(filename)
    region = image.get_region(margin, margin, image.width - margin * 2, image.height - margin * 2)
    grid = pyglet.image.ImageGrid(region,
                                  int(region.height / tileheight),
                                  int(region.width / tilewidth),
                                  row_padding=spacing,
                                  column_padding=spacing,
    )

    texture = grid.get_texture_sequence()

    if nearest:
        gl.glTexParameteri(texture.target, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST)
        gl.glTexParameteri(texture.target, gl.GL_TEXTURE_MAG_FILTER, gl.GL_NEAREST)

    return texture


class BaseLayer(object):
    """
    Base layer.

    Takes care of the "visible" flag.

    """
    # ordered group
    groups = 0
    min_hippieness = 0
    max_hippieness = 1000000000
    curVis = False

    def __init__(self, data, map):
        self.data = data
        self.map = map

        if self.data["visible"]:
            self.sprites = {}
            self.group = OrderedGroup(BaseLayer.groups)
            BaseLayer.groups += 1
        self.curVis = self.data["visible"]


class TileLayer(BaseLayer):
    """
    Tile layer.

    Provides a pythonic interface to the tile layer, including:

        - Iterate through the tiles.
        - Check if one coordinate exists in the layer.
        - Get one tile of layer.

    """
    def delete_sprites(self):
        for key in self.sprites.keys():
            self.sprites[key].delete()
            del self.sprites[key]
    sprites = None
    opacity = 255
    collision_layer = False
    death_layer = False
    climb_layer = False
    def delete_sprites(self):
        deleted = []
        if self.sprites is None:
            return
        for key in self.sprites.keys():
            if self.sprites[key] is not None:
                self.sprites[key].delete()
                deleted.append(key)
        for key in deleted:
            self.sprites[key]
        self.collision_layer = None
        self.death_layer = None
        self.climb_layer = None


    def __iter__(self):
        return iter(self.data)

    def __contains__(self, index):
        if type(index) != tuple:
            raise TypeError("tuple expected")

        x, y = index
        return int(x + y * self.map.data["width"]) in self.data["data"]

    def __getitem__(self, index):
        if type(index) != tuple:
            raise TypeError("tuple expected")

        x, y = index
        return self.data["data"][int(x + y * self.map.data["width"])]

    one_time = True

    def set_viewport(self, x, y, w, h):
        if not self.one_time:
            return
        self.one_time = False
        tw = self.map.data["tilewidth"]
        th = self.map.data["tileheight"]

        def yrange(f, t, s):
            while f < t:
                yield f
                f += s

        in_use = []
        self.min_hippieness = 0
        self.max_hippieness = 10000000000
        if "properties" in self.data.keys():
            if "collision" in self.data["properties"].keys():
                self.collision_layer = True
            if "climb" in self.data["properties"].keys():
                self.climb_layer = True
            if "death" in self.data["properties"].keys():
                self.death_layer = True
            if "slow" in self.data["properties"].keys():
                layer_batch = self.map.batch2
            elif "veryslow" in self.data["properties"].keys():
                layer_batch = self.map.batch3
            else:
                layer_batch = self.map.batch
            if "minhippieness" in self.data["properties"].keys():
                self.min_hippieness = self.data["properties"]["minhippieness"]
            else:
                self.min_hippieness = 0
            if "maxhippieness" in self.data["properties"].keys():
                self.max_hippieness = self.data["properties"]["maxhippieness"]
            else:
                self.max_hippieness = 1000000000
        else:
            layer_batch = self.map.batch

        for j in yrange(0, self.map.data["height"] * th, th):
            py = j // th
            for i in yrange(0, self.map.data["width"] * tw, tw):
                px = i // tw
                in_use.append((px, py))
                if (px, py) not in self.sprites:
                    try:
                        texture = self.map.get_texture(self[px, py])
                    except (KeyError, IndexError):
                        self.sprites[(px, py)] = None
                    else:
                        sprite = Sprite(texture,
                                        x=(px * tw),
                                        y=h - (py * th) - th,
                                        batch=self.map.batch,
                                        group=self.group,
                                        usage="static",
                        )
                        sprite.opacity = self.opacity
                        self.sprites[(px, py)] = sprite

    old_group = None

    def set_opacity(self, opacity):
        self.opacity = opacity
        if self.sprites is None:
            return
        for spr in self.sprites.keys():
            sprite = self.sprites[spr]
            if sprite is not None:
                sprite.opacity = opacity


class ObjectGroup(BaseLayer):
    """
    Object Group Layer.

    Only tile based objects will be drawn (not shape based).

    Provides a pythonic interface to the object layer, including:

        - Iterate through the objects.
        - Check if one coordinate or an object name exists in the layer.
        - Get one object based on its coordinates or its name.

    Also it is possible to get a list of objects of the same type with
    `ObjectGroup.get_by_type(type)`.

    """
    def delete_sprites(self):
        deleted = []
        #if self.sprites is None:
        return
        for key in self.sprites.keys():
            if self.sprites[key] is not None:
                self.sprites[key].delete()
                deleted.append(key)
        for key in deleted:
            self.sprites[key]
        self.death_layer = None
        self.climb_layer = None
        self.enemy_group = None
        self.climb_group = None
        self.death_group = None
        self.collision_group = None
    collision_layer = False
    death_layer = False
    climb_layer = False
    collision_group = []
    teleporter_group = []
    enemy_group = []
    climb_group = []
    death_group = []

    collectible_group = []
    def __init__(self, data, map):
        super(ObjectGroup, self).__init__(data, map)

        self.h = 0
        self.objects = []
        self._index = {}
        self._index_type = {}
        self._xy_index = {}

        for obj in data["objects"]:
            self.objects.append(obj)

            name = obj.get("name", "?")
            if name not in self._index:
                self._index[name] = []

            otype = obj.get("type", "?")
            if otype not in self._index_type:
                self._index_type[otype] = []

            x = int(obj["x"]) // self.map.data["tilewidth"]
            y = int(obj["y"]) // self.map.data["tileheight"] - 1
            if (x, y) not in self._xy_index:
                self._xy_index[x, y] = []

            self._index[name].append(self.objects[-1])
            self._index_type[otype].append(self.objects[-1])
            self._xy_index[x, y].append(self.objects[-1])

        # XXX: is this useful AT ALL?
        self.objects.sort(key=lambda obj: obj["x"] + obj["y"] * self.map.data["width"])

    def __iter__(self):
        return iter(self.objects)

    def __contains__(self, name):
        if isinstance(name, tuple):
            x, y = name
            return (int(x), int(y)) in self._xy_index
        return name in self._index

    def __getitem__(self, name):
        if isinstance(name, tuple):
            x, y = name
            # XXX: if there are several objects, expect the first one
            return self._xy_index[int(x), int(y)][0]
        return self._index[name]

    def get_by_type(self, otype):
        return self._index_type[otype]

    one_time = True

    def set_viewport(self, x, y, w, h):
        if not self.one_time:
            return
        self.one_time = False
        self.h = h
        tw = self.map.data["tilewidth"]
        th = self.map.data["tileheight"]

        in_use = []
        for obj in self.objects:
                if not obj["visible"]:
                    continue
                if "gid" in obj:
                    in_use.append((obj["x"], obj["y"]))
                    try:
                        texture = self.map.get_texture(obj["gid"])
                        tileoffset = self.map.get_tileoffset(obj["gid"])
                    except (IndexError, KeyError):
                        sprite = None
                    else:
                        if str.lower(obj["name"]) == "player":
                            sprite = PlayerAnimatedObject(obj["x"] + tileoffset[0], self.h - obj["y"] + tileoffset[1],
                                                          self.map.batch, self.group, "dynamic", )
                            obj["enemy"] = False
                        else:
                            object_dict = {"goose": GooseObject}
                            in_dict = False
                            for object in object_dict.keys():
                                if object == obj["type"]:
                                    sprite = object_dict[object](obj["x"] + tileoffset[0], self.h - obj["y"] + tileoffset[1],
                                                        self.map.batch, self.group, "dynamic", )
                                    GameState.get_instance().ai_list.append(sprite)
                                    sprite.object = obj
                                    obj["enemy"] = True
                                    self.enemy_group.append(obj)
                                    in_dict = True
                            if not in_dict:
                                sprite = Sprite(texture,
                                                x=obj["x"] + tileoffset[0],
                                                y=self.h - obj["y"] + tileoffset[1],
                                                batch=self.map.batch,
                                                group=self.group,
                                                usage="dynamic",
                                )
                                obj["enemy"] = False
                    if "collision" in obj["properties"].keys():
                        self.collision_group.append(obj)
                    if "teleport" in obj["properties"].keys():
                        self.teleporter_group.append(obj)
                    if "climb" in obj["properties"].keys():
                        self.climb_group.append(obj)
                    if "death" in obj["properties"].keys():
                        self.death_group.append(obj)
                    if "collectible" in obj["properties"].keys():
                        self.collectible_group.append(obj)


                    obj["sprite"] = sprite
                    obj["vx"] = 0
                    obj["vy"] = 0
                    obj["ay"] = 1
                    obj["jump"] = False
                    obj["portal"] = False
                    obj["portaltime"] = 0
                    obj["climb"] = False
                    self.sprites[(obj["x"], obj["y"])] = sprite

    def move(self, object):
        movement = 4
        jumpmovement = 1
        jumpspeed = 12
        boostspeed = 16
        glide = 1

        if "sprite" not in object.keys():
            return [0, 0]
        sprite = object["sprite"]
        vy = object["vy"]
        vx = object["vx"]
        d_y = 0
        d_x = 0
        teleporter = object["portal"]
        teleporttime = object["portaltime"]
        climb = object["climb"]
        jump = object["jump"]
        o_x = object["x"]
        o_y = object["y"]
        ay = object["ay"]
        for a in self.to_tile_coordinates(o_x, o_y + 1, object):
            if GameState.get_instance().tile_collide(a[0], a[1]) is not 0:
                if jump:
                    vy = jumpspeed
                    jump = False
        if vy > 0:
            if climb:
                vy = 1
                d_y = -movement
            else:
                vy -= ay
                d_y = -vy * jumpmovement
        if vy <= 0:
            if climb:
                if vy == 0:
                    d_y = 0
                else:
                    d_y = movement
                vy = 0
            else:
                vy -= ay
                d_y = -int(vy * jumpmovement * glide)
        if vx < 0:
            d_x = -movement
        elif vx > 0:
            d_x = movement

        vx = 0
        deltas = self.dydx_checker(o_x, o_y, d_x, d_y, object)
        d_x = deltas[0]
        d_y = deltas[1]

        self.sprites[(object["x"], object["y"])] = sprite
        if (o_x, o_y) in self.sprites.keys():
            del self.sprites[(o_x, o_y)]
        for a in self.collision_group:
            if a is not self:
                if self.intersect_object(object, a):
                    vy = int(a["properties"]["collision"])
        for a in self.teleporter_group:
            if teleporttime == 0 and teleporter and a is not self:
                if self.intersect_object(object, a):
                    goal = a["properties"]["teleport"]
                    for x in self.teleporter_group:
                        if int(x['id']) == int(goal):
                            d_x = x["x"] - object["x"]
                            d_y = x["y"] - object["y"]
                            teleporttime = 30
                            object["portal"] = False
        for a in self.enemy_group:
            if self.intersect_object(object, a):
                print("lol, u died, noob")
                GameState.get_state().game_state ="D"


        b_climb = False
        for a in self.to_tile_coordinates(object["x"], object["y"], object):
            if GameState.get_instance().tile_climb(a[0], a[1]) is not 0:
                b_climb = True
        if b_climb:
            vy = 0
            object["climb"] = True
        else:
            object["climb"] = False
        if teleporter:
            object["portal"] = False
        if teleporttime > 0:
            teleporttime -= 1
        sprite.x += d_x
        sprite.y -= d_y
        object["portaltime"] = teleporttime
        object["x"] += d_x
        object["y"] += d_y
        object["vy"] = vy
        object["vx"] = vx
        for a in self.collectible_group:
            if a is not self:
                if self.intersect_object(object, a):
                    print("pick up : " + str(a["id"]))

        for a in self.to_tile_coordinates(object["x"], object["y"], object):
            if GameState.get_instance().tile_death(a[0], a[1]) is not 0:
                print("lol dood n00b l2p, 3sp00ky5me ayy lmao u ded m8")
                GameState.get_instance().game_state ="D"
        return [d_x, d_y]

    def dydx_checker(self, o_x, o_y, d_x, d_y, object):
        iy = 0
        ix = 0
        # eerst over y itereren dan x
        if d_y != 0:
            if d_y > 0:
                for i in range(0, d_y):
                    result = self.collision_detection(o_x, o_y + i, 0, 1, object)
                    if result[1] != 1:
                        break
                    iy += 1
            else:
                for i in range(0, d_y, -1):
                    result = self.collision_detection(o_x, o_y + i, 0, -1, object)
                    if result[1] != -1:
                        break
                    iy -= 1
        if d_x != 0:
            if d_x > 0:
                for i in range(0, d_x):
                    result = self.collision_detection(o_x + i, o_y + iy, 1, 0, object)
                    if result[0] != 1:
                        break
                    ix += 1
            else:
                for i in range(0, d_x, -1):
                    result = self.collision_detection(o_x + i, o_y + iy, -1, 0, object)
                    if result[0] != -1:
                        break
                    ix -= 1
        return [ix, iy]

    def intersect_object(self, a, b):
        x1 = [a["x"], a["y"]]
        x2 = [a["x"] + a["width"], a["y"]]
        x3 = [a["x"], a["y"] - a["height"]]
        x4 = [a["x"] + a["width"], a["y"] - a["height"]]
        y1 = [b["x"], b["y"]]
        y2 = [b["x"] + b["width"], b["y"]]
        y3 = [b["x"], b["y"] - b["height"]]
        y4 = [b["x"] + b["width"], b["y"] - b["height"]]
        xmax = max(x1[0], x2[0], x3[0], x4[0])
        ymax = max(x1[1], x2[1], x3[1], x4[1])
        xmin = min(x1[0], x2[0], x3[0], x4[0])
        ymin = min(x1[1], x2[1], x3[1], x4[1])
        if (xmin <= y1[0] <= xmax and ymin <= y1[1] <= ymax) \
                or (xmin <= y2[0] <= xmax and ymin <= y2[1] <= ymax) \
                or (xmin <= y3[0] <= xmax and ymin <= y3[1] <= ymax) \
                or (xmin <= y4[0] <= xmax and ymin <= y4[1] <= ymax):
            return True
        xmax = max(y1[0], y2[0], y3[0], y4[0])
        ymax = max(y1[1], y2[1], y3[1], y4[1])
        xmin = min(y1[0], y2[0], y3[0], y4[0])
        ymin = min(y1[1], y2[1], y3[1], y4[1])
        if (xmin <= x1[0] <= xmax and ymin <= x1[1] <= ymax) \
                or (xmin <= x2[0] <= xmax and ymin <= x2[1] <= ymax) \
                or (xmin <= x3[0] <= xmax and ymin <= x3[1] <= ymax) \
                or (xmin <= x4[0] <= xmax and ymin <= x4[1] <= ymax):
            return True
        return False

    def collision_detection(self, o_x, o_y, d_x, d_y, object):
        b_check = True
        tile_collide = GameState.get_instance().tile_collide
        for a in self.to_tile_coordinates(o_x + d_x, o_y + d_y, object):
            if tile_collide(a[0], a[1]) is not 0:
                b_check = False
        if not b_check:
            x_check = True
            for a in self.to_tile_coordinates(o_x + d_x, o_y, object):
                if tile_collide(a[0], a[1]) is not 0:
                    x_check = False
            if x_check:
                d_y = 0
            else:
                y_check = True
                for a in self.to_tile_coordinates(o_x, o_y + d_y, object):
                    if tile_collide(a[0], a[1]) is not 0:
                        y_check = False
                if y_check:
                    d_x = 0
                else:
                    return [0, 0]
        return [d_x, d_y]

    def to_tile_coordinates(self, o_x, o_y, object):
        ret = []
        oo_x = math.floor(o_x / self.map.data["tilewidth"])

        oo_y = math.floor(o_y / self.map.data["tileheight"])

        tilesx = math.ceil(object["width"] / self.map.data["tilewidth"])
        tilesy = math.ceil(object["height"] / self.map.data["tileheight"])
        if tilesx * self.map.data["tilewidth"] == object["width"]:
            tilesx += 1
        if tilesy * self.map.data["tileheight"] == object["height"]:
            tilesy += 1

        for i in range(0, tilesx):
            for j in range(0, tilesy):
                ret.append((oo_x + i, oo_y - j))

        return ret

    def set_opacity(self, opacity):
        for object in self.objects:
            if "sprite" in object.keys():
                object["sprite"].opacity = opacity


class Tileset(object):
    """Manages a tileset and it's used internally by TileLayer."""

    def __init__(self, data, nearest=False):
        self.data = data

        # used to convert coordinates of the grid
        self.columns = (self.data["imagewidth"] - self.data["spacing"] * 2) // (
        self.data["tilewidth"] - self.data["margin"])
        self.rows = (self.data["imageheight"] - self.data["spacing"] * 2) // (
        self.data["tileheight"] - self.data["margin"])

        # the image will be accessed using pyglet resources
        self.image = os.path.basename(self.data["image"])
        self.texture = get_texture_sequence(self.image, self.data["tilewidth"],
                                            self.data["tileheight"],
                                            self.data["margin"],
                                            self.data["spacing"],
                                            nearest=False,
        )

    def __getitem__(self, index):
        return self.texture[index]

    def __len__(self):
        return len(self.texture)


class Map(object):
    """
    Load, manage and render Tiled JSON files.

    Maps can created providing the JSON data to this class or using `Map.load_json()`
    and after that a viewport must be set with `Map.set_viewport()`.
    """

    def __init__(self, data, nearest=False):
        self.data = data

        self.tilesets = {}  # the order is not important

        self.layers = []
        self.tilelayers = {}
        self.objectgroups = {}

        for tileset in data["tilesets"]:
            self.tilesets[tileset["name"]] = Tileset(tileset, nearest)

        for layer in data["layers"]:
            # TODO: test this!
            if layer['name'] in (self.tilelayers, self.objectgroups):
                raise ValueError("Duplicated layer name %s" % layer["name"])

            if layer["type"] == "tilelayer":
                self.layers.append(TileLayer(layer, self))
                self.tilelayers[layer["name"]] = self.layers[-1]
            elif layer["type"] == "objectgroup":
                self.layers.append(ObjectGroup(layer, self))
                self.objectgroups[layer["name"]] = self.layers[-1]
            else:
                raise ValueError("unsupported layer type %s, skipping" % layer["type"])

        self.batch = pyglet.graphics.Batch()
        self.batch2 = pyglet.graphics.Batch()
        self.batch3 = pyglet.graphics.Batch()


        # viewport
        self.x = 0
        self.y = 0
        self.w = 0
        self.h = 0

        # focus
        self.fx = None
        self.fy = None

        # useful (size in pixels)
        self.p_width = self.data["width"] * self.data["tilewidth"]
        self.p_height = self.data["height"] * self.data["tileheight"]

        # build a texture index converting pyglet indexing of the texture grid
        # to tiled coordinate system
        self.tileoffset_index = {}
        self.texture_index = {}
        for tileset in self.tilesets.values():
            for y in range(tileset.rows):
                for x in range(tileset.columns):
                    self.texture_index[x + y * tileset.columns + tileset.data["firstgid"]] = \
                        tileset[(tileset.rows - 1 - y), x]

                    # TODO: test this!
                    if "tileoffset" in tileset.data:
                        self.tileoffset_index[x + y * tileset.columns + tileset.data["firstgid"]] = \
                            (tileset.data["tileoffset"]["x"], tileset.data["tileoffset"]["y"])

    def invalidate(self):
        """Forces a batch update of the map."""
        self.set_viewport(self.x, self.y, self.w, self.h, True)

    def move_viewport(self, x, y):
        self.set_viewport(self.x + x, self.y + y, self.w, self.h)

    first = True

    def set_viewport(self, x, y, w, h, force=False):
        """
        Sets the map viewport to the screen coordinates.

        Optionally the force flag can be used to update the batch even if the
        viewport didn't change (this should be used via `Map.invalidate()`).
        """
        # x and y can be floats
        vx = max(x, 0)
        vy = max(y, 0)
        vx = min(vx, (self.p_width) - w)
        vy = min(vy, (self.p_height) - h)
        vw = int(w)
        vh = int(h)

        if not any([force, vx != self.x, vy != self.y, vw != self.w, vh != self.h]):
            return

        self.x = vx
        self.y = vy
        self.w = vw
        self.h = vh
        for layer in self.layers:
            if layer.data["visible"]:
                layer.set_viewport(self.x, self.y, self.w, self.h)

    def move_focus(self, dx, dy):
        self.set_focus(self.x + dx, self.y + dy)

    def set_focus(self, x, y):
        """Sets the focus in (x, y) world coordinates."""
        x = int(x)
        y = int(y)
        if self.fx == x and self.fy == y:
            return

        self.fx = x
        self.fy = y

        vx = max(x - (self.w // 2), 0)
        vy = max(y - (self.h // 2), 0)

        if vx + (self.w // 2) > self.p_width:
            vx = self.p_width - self.w

        if vy + (self.h // 2) > self.p_height:
            vy = self.p_height - self.h

        self.set_viewport(vx, vy, self.w, self.h)

    def world_to_screen(self, x, y):
        """
        Translate world coordinate into screen coordinates.

        Returns a (x, y) tuple.
        """
        return x - self.x, self.h - (y - self.y)

    def get_texture(self, gid):
        """
        Returns a texture identified by its gid.

        If not found will raise a KeyError or IndexError.
        """
        return self.texture_index[gid]

    def get_tileoffset(self, gid):
        """Returns the offset of a tile."""
        return self.tileoffset_index.get(gid, (0, 0))

    @property
    def last_group(self):
        """
        The last use group in `Map` batch.

        This is useful in case any Sprite is added to the `Map` to
        be drawn by the Map's batch without being managed by the Map.

        Using this value plus one will ensure the sprite will be drawn
        over the map.
        """
        return BaseLayer.groups - 1

    @staticmethod
    def load_json(fileobj, nearest=False):
        """
        Load the map in JSON format.

        This class method return a `Map` object and the file will be
        closed after is read.

        Set nearest to True to set GL_NEAREST for both min and mag
        filters in the tile textures.
        """
        data = json.load(fileobj)
        fileobj.close()
        return Map(data, nearest)

    def draw(self):
        """Applies transforms and draws the batch."""
        # warp_slow_x = 0.5
        #warp_slow_y = 0.5
        #warp_very_slow_x = 0.3
        #warp_very_slow_y = 0.3


        gl.glPushMatrix()
        gl.glTranslatef(-int(self.x * warp_very_slow_x), int(self.y * warp_very_slow_x), 0)
        self.batch3.draw()
        gl.glPopMatrix()
        gl.glPushMatrix()
        gl.glTranslatef(-int(self.x * warp_slow_x), int(self.y * warp_slow_x), 0)
        self.batch2.draw()
        gl.glPopMatrix()
        gl.glPushMatrix()
        gl.glTranslatef(-int(self.x ), int(self.y ), 0)
        self.batch.draw()
        gl.glPopMatrix()
        glFlush()